#!/usr/bin/env bash

wd="$(mktemp -t "debian.XXXXXXXXXXXXXXXX" -d 2>/dev/null)"

function installed() {
    command -v "$1" >/dev/null 2>&1
}

function warn() {
    echo -e "\033[1;33m${*}\033[0m"
}

function error() {
    echo -e "\033[1;31m${*}\033[0m"
    exit 1
}

function info() {
    echo -e "\033[1;32m${*}\033[0m"
}

function download() {
    local url="$1"
    local target="$2"
    if [ -z "$target" ]; then
        target="$(basename "$url")"
    fi
    target_dir="$(dirname "$target")"
    if [ ! -d "$target_dir" ]; then
        mkdir -p "$target_dir"
    fi
    [ -f "$target" ] && rm -rf "$target"
    echo "Downloading $url to $target"
    if ! curl --progress-bar -sf -Lo "$target" "$url"; then
        error "Failed to download $url"
    fi
}

function cidr_to_netmask() {
    set -- $((5 - ($1 / 8))) 255 255 255 255 $(((255 << (8 - ($1 % 8))) & 255)) 0 0 0
    # shellcheck disable=SC2015
    [ "$1" -gt 1 ] && shift "$1" || shift
    echo "${1-0}"."${2-0}"."${3-0}"."${4-0}"
}

# shellcheck disable=SC2120
function ip_address() {
    if="$1"
    type="$2"
    [ -z "$type" ] && type="4"
    # shellcheck disable=SC2119
    [ -z "$if" ] && if="$(default_interface)"
    ip -"$type" -o addr show "$if" | head -1 | awk '{split($4,a,"/"); print a[1]}'
}
# shellcheck disable=SC2120
function netmask() {
    if="$1"
    type="$2"
    [ -z "$type" ] && type="4"
    # shellcheck disable=SC2119
    [ -z "$if" ] && if="$(default_interface)"
    local mask=""
    if [ "$type" == "6" ]; then
        mask=$(ip -"$type" -o addr show "$if" | awk '{split($4,a,"/"); print a[2]}')
    else
        mask=$(cidr_to_netmask "$(ip -"$type" -o addr show "$if" | head -1 | awk '{split($4,a,"/"); print a[2]}')")
    fi
    # dirty hack for google cloud, and Nerocloud Ltd
    if [ "$type" == "4" ] && [ "$mask" == "255.255.255.255" ]; then
        asn=$(curl -s -"$type" "https://ipconfig.io/json" | jq -r '.asn_org' 2>/dev/null)
        if [ "$asn" == "GOOGLE-CLOUD-PLATFORM" ]; then
            mask="255.255.255.0"
            mirror_protocol="http"
        fi
    fi
    [ -z "$mask" ] && error "failed to get netmask"
    echo "$mask"
}

# shellcheck disable=SC2120
function default_gateway() {
    type="$1"
    [ -z "$type" ] && type="4"
    ip -"$type" route show default | awk '{print $3}' | head -n1
}

# shellcheck disable=SC2120
function default_interface() {
    type="$1"
    [ -z "$type" ] && type="4"
    ip -"$type" route show default | awk '{print $5}' | head -n1
}

# get current dns server
function dns() {
    resolvectl dns -i "$(default_interface)" 2>/dev/null | awk '{print $4}'
}

function ipv6_enabled() {
    public_ipv6="$(curl --connect-timeout 5 -m 10 -6 -sL https://ifconfig.co 2>/dev/null)" ||
        public_ipv6="$(curl --connect-timeout 5 -m 10 -6 -sL https://ipconfig.io 2>/dev/null)"
    [ -z "$public_ipv6" ] && return 1
    return 0
}

function get_disk() {
    # lsblk -oMOUNTPOINT,PKNAME -P | grep 'MOUNTPOINT="/"' | cut -d'"' -f4 | sed 's/[n][0-9]//g'
    lsblk -oMOUNTPOINT,PKNAME -rn | awk '$1 ~ /^\/$/ { print $2 }'
}

function has_cloud_kernel() {
    local suite="$1"
    local arch="$2"
    local use_backports="$3"
    local mirror="$4"
    [ "$use_backports" == true ] && suite="$suite-backports"
    packages_url="$mirror/dists/$suite/main/binary-$arch/Packages.xz"
    kernels="$(curl -sL "$packages_url" | xzgrep -c 'Package: linux-image-cloud-'"$arch"'$')"
    if [ "$kernels" -gt 0 ]; then
        return 0
    fi

    warn "No cloud kernel is available for $arch/$suite"
    return 1
}

function has_backports() {
    local suite="$1-backports"
    local arch="$2"
    local mirror="$3"
    local debian_packages=""
    packages_url="$mirror/dists/$suite/main/binary-$arch/Packages.xz"
    debian_packages="$(curl -sL "$packages_url" | xzgrep -c "Package: .*")"
    if [ "$debian_packages" -gt 0 ]; then
        return 0
    fi

    warn "backports repository is not available for $arch/$suite"
    return 1
}

has_bpo_kernel() {
    local suite="$1-backports"
    local arch="$2"
    local mirror="$3"
    local debian_packages=""
    packages_url="$mirror/dists/$suite/main/binary-$arch/Packages.xz"
    debian_packages="$(curl -sL "$packages_url" | xzgrep -c 'Package: linux-image-'"$arch"'$')"
    if [ "$debian_packages" -gt 0 ]; then
        return 0
    fi

    warn "bpo kernel is not available for $arch/$suite"
    return 1
}

[ ! -d "$wd" ] && error "failed to create working directory"

if ((EUID != 0)); then
    echo "Granting root privileges for ""$(basename "$0")"
    if [ -t 1 ]; then
        sudo "$0" "$@"
    else
        exec 1>output_file
        gksu "$0" "$@"
    fi
    exit
fi

base="https://debian.lol"
github_base="https://raw.githubusercontent.com/mysqto/install/gh-pages"

# check connection to base url
if ! curl -sL --connect-timeout 5 "$base" >/dev/null 2>&1; then
    echo "Failed to connect to $base"
    echo "try to use github url $github_base"
    base="$github_base"
    # check connection to base url again
    if ! curl -sL --connect-timeout 5 "$base" >/dev/null 2>&1; then
        echo "Failed to connect to $base"
        exit 1
    fi
fi

# debug flag
dry_run=false
# systen related
arch=
version=stable
suite=
# mirror related
mirror_protocol=https
mirror_host=deb.debian.org
mirror_directory=/debian
mirror_proxy=
security_repository=http://security.debian.org/debian-security
security_archive=
daily=
# account related
username=
uid=
password=
password_hash=
authorized_keys=
authorized_keys_url=
# network related
static_ip=false
interface=auto
hostname=
domain=
timezone=
ntp_server=
network_console=false
nc_password=
bbr=false
# partition related
filesystem=ext4
firmware=false
disk=
efi=
gpt=true
esp=
boot_size=
# boot related
force_efi_extra_removable=false
force_lowmem=
#kernel and upgrade related
upgrade=safe-upgrade
kernel=
bpo_kernel=true
cloud_kernel=false
kernel_params=
packages="openssh-server build-essential curl wget net-tools git vim tig"

# extra packages config
provision=false
install_socat=false
ssh_port=
install_go=false
install_im=false
install_neofetch=false
install_fish=false
use_backports=false
byobu=false
sudo_without_password=false

# Shadowsocks related
install_shadowsocks=
shadowsocks_password=
shadowsocks_port=
shadowsocks_obfs_host=
shadowsocks_config="/etc/shadowsocks-libev/config.json"

# Shadow-TLS related
install_shadow_tls=
snell_port=
snell_psk=
shadow_tls_port=
shadow_tls_password=
shadow_tls_obfs_host=
snell_version=4
snell_config_file="/etc/snell/snell-server.conf"
shadow_tls_default_file="/etc/default/shadow-tls"

boot_dir="/boot"
grub_d="/etc/grub.d"
grub_custom_file="$grub_d/40_custom"

# prepare for dpkg and install necessary packages
if installed apt-get; then
    dependencies=(
        systemd
        pwgen
        whois
        curl
        cpio
        openssh-client
        jq
        xz-utils
    )

    to_install=()
    for dependency in "${dependencies[@]}"; do
        if ! dpkg -s "$dependency" >/dev/null 2>&1; then
            to_install+=("$dependency")
        fi
    done

    DEBIAN_FRONTEND=noninteractive \
        apt -y update &&
        apt -y \
            -o Dpkg::Options::="--force-confdef" \
            -o Dpkg::Options::="--force-confold" \
            --no-install-recommends \
            install \
            "${to_install[@]}"
fi

if installed yum; then
    dependencies=(
        systemd
        expect
        whois
        curl
        cpio
        openssh-clients
        jq
        xz-utils
    )

    to_install=()

    for dependency in "${dependencies[@]}"; do
        if ! rpm -q "$dependency" >/dev/null 2>&1; then
            to_install+=("$dependency")
        fi
    done

    yum -y install "${to_install[@]}"
fi

[ -z "$arch" ] && {
    arch=$(dpkg --print-architecture 2>/dev/null) || {
        case $(uname -m) in
        x86_64)
            arch=amd64
            ;;
        aarch64)
            arch=arm64
            ;;
        i386)
            arch=i386
            ;;
        *)
            error 'No "--architecture" specified'
            ;;
        esac
    }
}

[ -z "$arch" ] && {
    error "failed to detect architecture, please specify it with --architecture"
}

POSITIONAL=()

while [ $# -gt 0 ]; do
    case "$1" in
    -v | --version)
        version="$2"
        shift 2
        ;;
    --cdn | --aws)
        mirror_protocol=https
        [ "$1" = '--aws' ] && mirror_host=cdn-aws.deb.debian.org
        security_repository=mirror
        shift
        ;;
    --cn | --china | -cn | --aliyun)
        dns='223.5.5.5 223.6.6.6'
        mirror_protocol=https
        mirror_host=mirrors.aliyun.com
        ntp_server=ntp.aliyun.com
        security_repository=mirror
        shift
        ;;
    -a | --architecture)
        arch="$2"
        shift 2
        ;;
    -bbr | --bbr)
        bbr=true
        shift
        ;;
    -boot | --boot-size)
        boot_size="$2"
        shift 2
        ;;
    -d | --disk)
        disk="$2"
        shift 2
        ;;
    -e | --efi)
        efi=true
        shift
        ;;
    -esp | --esp-size)
        esp="$2"
        shift 2
        ;;
    --ethx)
        kernel_params="$kernel_params net.ifnames=0 biosdevname=0"
        ;;
    -f | --filesystem)
        filesystem="$2"
        shift 2
        ;;
    -u | --user)
        username="$2"
        shift 2
        ;;
    -uid | --uid)
        uid="$2"
        shift 2
        ;;
    -p | --password)
        password="$2"
        shift 2
        ;;
    -g | --gpt)
        gpt=true
        shift
        ;;
    -i | --interface)
        interface="$2"
        shift 2
        ;;
    -h | --hostname)
        hostname="$2"
        shift 2
        ;;
    -bpo | --backports-kernel)
        bpo_kernel=true
        shift
        ;;
    -cloud | --cloud-kernel)
        cloud_kernel=true
        shift
        ;;
    -t | --timezone)
        timezone="$2"
        shift 2
        ;;
    -n | --ntp-server)
        ntp_server="$2"
        shift 2
        ;;
    -ns | --network-console)
        network_console=true
        shift
        ;;
    -mp | --mirror-protocol)
        if [ "$2" != "http" ] && [ "$2" != "https" ] && [ "$2" != "ftp" ]; then
            warn "invalid mirror protocol $2, only http, https and ftp are supported, use https as default"
            mirror_protocol="https"
        else
            mirror_protocol="$2"
        fi
        shift 2
        ;;
    -mh | --mirror-host)
        mirror_host="$2"
        shift 2
        ;;
    -md | --mirror-directory)
        mirror_directory=${2%/}
        shift 2
        ;;
    -s | --static-ip)
        static_ip=true
        shift
        ;;
    -ip | --ip-address)
        ip_address="$2"
        shift 2
        ;;
    -nm | --netmask)
        netmask="$2"
        shift 2
        ;;
    -gw | --gateway)
        gateway="$2"
        shift 2
        ;;
    -dns | --dns)
        dns="$2"
        shift 2
        ;;
    -sr | --security-repository)
        security_repository="$2"
        shift 2
        ;;
    --force-efi-extra-removable)
        force_efi_extra_removable=true
        shift
        ;;
    --upgrade)
        if [ "$2" != "none" ] && [ "$2" != "safe-upgrade" ] && [ "$2" != "full-upgrade" ]; then
            warn "invalid upgrade type $2, only none, safe-upgrade and full-upgrade are supported, use safe-upgrade as default"
            upgrade="safe-upgrade"
        else
            upgrade="$2"
        fi
        shift 2
        ;;
    --force-lowmem)
        [ "$2" != 0 ] && [ "$2" != 1 ] && [ "$2" != 2 ] && error 'Low memory level can only be 0, 1 or 2'
        force_lowmem=$2
        shift
        ;;
    --daily)
        daily=true
        shift
        ;;
    --dry-run)
        dry_run=true
        shift
        ;;
    --firmware)
        firmware=true
        shift
        ;;
    --provision)
        provision=true
        version=stable
        install_shadowsocks=true
        install_shadow_tls=true
        install_go=true
        install_im=true
        install_fish=true
        install_neofetch=true
        use_backports=true
        bbr=true
        byobu=true
        bpo_kernel=true
        cloud_kernel=true
        shift
        ;;
    -m | --minimal)
        provision=true
        version=stable
        install_im=true
        install_fish=true
        install_neofetch=true
        use_backports=true
        bbr=true
        byobu=true
        bpo_kernel=true
        cloud_kernel=true
        shift
        ;;
    -ak | --authorized-keys)
        authorized_keys="$2"
        shift 2
        ;;
    -aku | --authorized-keys-url)
        authorized_keys_url="$2"
        shift 2
        ;;
    -stls | --shadow-tls)
        install_shadow_tls=true
        shift
        ;;
    --shadow-tls-port)
        shadow_tls_port="$2"
        shift 2
        ;;
    --shadow-tls-password)
        shadow_tls_password="$2"
        shift 2
        ;;
    --snell-port)
        snell_port="$2"
        shift 2
        ;;
    --snell-psk)
        snell_psk="$2"
        shift 2
        ;;
    --shadow-tls-obfs)
        shadow_tls_obfs_host="$2"
        shift 2
        ;;
    -ss | --shadowsocks-libev)
        install_shadowsocks=true
        shift
        ;;
    -ssp | --shadowsocks-password)
        shadowsocks_password="$2"
        shift 2
        ;;
    -sspobfs | --shadowsocks-obfs-host)
        shadowsocks_obfs_host="$2"
        shift 2
        ;;
    -sspt | --shadowsocks-port)
        shadowsocks_port="$2"
        shift 2
        ;;
    --socat)
        install_socat=true
        shift
        ;;
    --ssh | --ssh-port)
        ssh_port="$2"
        shift 2
        ;;
    --go)
        install_go=true
        shift
        ;;
    --im)
        install_im=true
        shift
        ;;
    --fish)
        install_fish=true
        shift
        ;;
    --neofetch)
        install_neofetch=true
        shift
        ;;
    --backports)
        use_backports=true
        shift
        ;;
    --byobu)
        byobu=true
        shift
        ;;
    --sudo-without-password)
        sudo_without_password=true
        shift
        ;;
    *)
        POSITIONAL+=("$1")
        shift
        ;;
    esac
done

set -- "${POSITIONAL[@]}" # restore positional parameters

[ -z "$version" ] && {
    echo "version is not specified, use stable as default"
    version=stable
}

mirror_base="$mirror_protocol://$mirror_host$mirror_directory"
# remove ending slash
mirror_base=${mirror_base%/}

case $version in
10 | buster | oldoldstable)
    suite=buster
    ;;
11 | bullseye | oldstable)
    suite=bullseye
    ;;
12 | bookworm | stable)
    suite=bookworm
    ;;
13 | trixie | testing)
    suite=bookworm
    ;;
sid | unstable)
    suite=sid
    ;;
*)
    error "Unsupported version: $version"
    ;;
esac

[ -z "$force_lowmem" ] && {
    memory_size=$(awk '/MemTotal/ {print $2}' /proc/meminfo 2>/dev/null)
    [ -n "$memory_size" ] || force_lowmem=0
    [ "$memory_size" -le "524288" ] && {
        warn "memory size <= 512MB, force to use low memory mode & cloud kernel"
        force_lowmem=1
        cloud_kernel=true
        bpo_kernel=true
    } || force_lowmem=0
}

[ $bpo_kernel == true ] && {
    if ! has_backports "$suite" "$arch" "$mirror_base"; then
        warn "backports repository is not available for $suite, use stable repository instead"
        use_backports=false
    fi
    if ! has_bpo_kernel "$suite" "$arch" "$mirror_base"; then
        warn "bpo kernel is not available for $suite, use stable kernel instead"
        bpo_kernel=false
    fi
}

[ -z "$kernel" ] && {
    kernel="linux-image-$arch"
    [ "$cloud_kernel" == true ] && has_cloud_kernel "$suite" "$arch" "$use_backports" "$mirror_base" && kernel="linux-image-cloud-$arch"
    [ "$bpo_kernel" == true ] && has_bpo_kernel "$suite" "$arch" "$mirror_base" && packages="$kernel/$suite-backports $packages"
}

[ -z "$daily" ] && {
    case $suite in
    buster | oldoldstable | bullseye | oldstable | bookworm | stable)
        daily=false
        ;;
    trixie | testing | sid | unstable)
        daily=true
        ;;
    esac
}

[ -z "$efi" ] && {
    efi=false
    [ -d /sys/firmware/efi ] && efi=true
}

[ ! -d /sys/firmware/efi ] && {
    if [ "$efi" == true ]; then
        warn "efi is not supported on this machine, fallback to legacy boot"
        efi=false
    fi
}

[ "$efi" == true ] && {
    [ "$gpt" == false ] && {
        warn "efi is only supported on gpt partition table, force to use gpt"
        gpt=true
    }

}

[ -z "$filesystem" ] && filesystem="$(blkid -o value -s TYPE "/")"
[ -z "$filesystem" ] && filesystem="ext4"
[ -z "$esp" ] && esp="$(fdisk -l 2>/dev/null | grep -E 'EFI System|EFI' | awk '{print $5}' | head -n1 | sed 's/.$//')"
[ -z "$esp" ] && esp="128"
[ -z "$boot_size" ] && boot_size="$(lsblk -oMOUNTPOINT,SIZE -P | grep -E '^MOUNTPOINT="/boot"' | grep -Eo 'SIZE="[^"]+"' | grep -Eo '[0-9]+')"
[ -z "$boot_size" ] && boot_size="512"

# random if not specified
[ -z "$username" ] && username=$(LC_ALL=C tr </dev/urandom -dc 'a-zA-Z0-9' | head -c 8)

[ -z "$full_name" ] && full_name="$(grep </etc/passwd "^$username:" | cut -d: -f5 | cut -d, -f1)"
[ -z "$full_name" ] && full_name="$username"

[ -z "$uid" ] && uid=$(id -u "$username" 2>/dev/null)
[ -z "$uid" ] && uid=$(LC_ALL=C tr </dev/urandom -dc '0-9' | head -c 4)

# random password if not specified
[ -z "$password" ] && {
    password_hash=$(grep </etc/shadow "^$username:" | cut -d: -f2)
}

if [ -z "$password_hash" ]; then
    [ -z "$password" ] && {
        password="$(pwgen -nsy 32 1 2>/dev/null)" ||
            password="$(mkpasswd -l 32 -C 16 -s 4 2>/dev/null)" ||
            password="$(openssl rand -base64 32 2>/dev/null)" ||
            password="$(busybox mkpasswd -l 32 -C 16 -s 4 2>/dev/null)" ||
            password="$(tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 32 2>/dev/null)"
    }

    salt="$(pwgen -nsy 16 1 2>/dev/null)" ||
        salt="$(mkpasswd -l 16 -C 8 -s 4 2>/dev/null)" ||
        salt="$(openssl rand -base64 16 2>/dev/null)" ||
        salt="$(busybox mkpasswd -l 16 -C 8 -s 4 2>/dev/null)" ||
        salt="$(tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 16 2>/dev/null)"

    password_hash="$(mkpasswd -m sha-512 -S "$salt" "$password" 2>/dev/null)" ||
        password_hash="$(openssl passwd -6 "$password" 2>/dev/null)" ||
        password_hash="$(busybox mkpasswd -m sha-512 -S "$salt" "$password" 2>/dev/null)" || {
        for python in python3 python python2; do
            installed "$python" || continue
            password_hash=$("$python" -c 'import crypt, sys; print(crypt.crypt(sys.argv[1], crypt.mksalt(crypt.METHOD_SHA256)))' "$password" 2>/dev/null) && break
        done
    }

fi

[ -z "$password_hash" ] && error "failed to get password hash"

[ -z "$hostname" ] && hostname="$(hostname)"
[ -z "$hostname" ] && hostname="$(cat /etc/hostname 2>/dev/null)"
[ -z "$hostname" ] && hostname="$(cat /proc/sys/kernel/hostname 2>/dev/null)"
[ -z "$hostname" ] && hostname=$(LC_ALL=C tr </dev/urandom -dc 'a-zA-Z0-9' | head -c 8)

domain=$(cat </proc/sys/kernel/domainname 2>/dev/null)
if [ "$domain" = '(none)' ]; then
    domain=
else
    domain=" $domain"
fi

[ -z "$timezone" ] && timezone="$(curl -sL http://ifconfig.co/json | jq -r ".time_zone")"
[ -z "$timezone" ] && timezone="$(cat /etc/timezone 2>/dev/null)"
[ -z "$timezone" ] && timezone="$(realpath /etc/localtime 2>/dev/null | sed 's/\/usr\/share\/zoneinfo\///')"
[ -z "$timezone" ] && timezone="$(timedatectl 2>/dev/null | awk '/Time zone:/ {print $3}')"
[ -z "$timezone" ] && timezone="UTC"

[ -z "$ntp_server" ] && ntp_server="$(timedatectl 2>/dev/null | awk '/NTP:/ {print $3}')"
[ -z "$ntp_server" ] && ntp_server="time.cloudflare.com"

[ "$install_shadowsocks" = true ] && {
    [ -z "$shadowsocks_password" ] && {
        [ -f "$shadowsocks_config" ] && shadowsocks_password="$(grep 2>/dev/null <"$shadowsocks_config" -Eo "\"password\"\s*:\s*\"[^\"]+\"" | cut -d'"' -f4)"
        [ -z "$shadowsocks_password" ] && {
            shadowsocks_password="$(pwgen -ns 32 1 2>/dev/null)" ||
                shadowsocks_password="$(busybox pwgen -ns 32 1 2>/dev/null)" ||
                shadowsocks_password="$(openssl rand -base64 32 2>/dev/null)" ||
                shadowsocks_password="$(busybox mkpasswd -l 32 -C 16 2>/dev/null)" ||
                shadowsocks_password="$(tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 32 2>/dev/null)"
        }
        [ -z "$shadowsocks_password" ] && error "Shadowsocks password is required with --shadowsocks, please re-run the script with --shadowsocks-password option"
    }

    [ -z "$shadowsocks_port" ] && {
        [ -f "$shadowsocks_config" ] && shadowsocks_port="$(grep 2>/dev/null <"$shadowsocks_config" -Eo "\"server_port\"\s*:\s*[0-9]+[^,]" | cut -d: -f2 | tr -d ' ')"
        while [ -z "$shadowsocks_port" ] || [ "$shadowsocks_port" = "$ssh_port" ]; do
            shadowsocks_port=$(shuf -i 10000-65535 -n 1 2>/dev/null) ||
                shadowsocks_port=$(awk -v min=10000 -v max=65535 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
        done
        [ -z "$shadowsocks_port" ] && error "Shadowsocks port is required with --shadowsocks, please re-run the script with --shadowsocks-port option"
    }

    [ -z "$shadowsocks_obfs_host" ] && {
        [ -f "$shadowsocks_config" ] && shadowsocks_obfs_host="$(grep 2>/dev/null <"$shadowsocks_config" -Eo "obfs-host=.*[^,\"]" | cut -d'=' -f2)"
        [ -z "$shadowsocks_obfs_host" ] && {
            warn "shadowsocks obfs host is not set, will use gateway.icloud.com as default"
            shadowsocks_obfs_host="gateway.icloud.com"
        }
    }
}

[ "$install_shadow_tls" = true ] && {
    [ -z "$snell_port" ] && {
        [ -f "$snell_config_file" ] && snell_port="$(grep 2>/dev/null <"$snell_config_file" -oE "listen = .*" | awk -F ':' '{print $NF}' | tr -d ' ')"
        while [ -z "$snell_port" ] || [ "$snell_port" = "$shadowsocks_port" ] || [ "$snell_port" = "$ssh_port" ]; do
            snell_port=$(shuf -i 10000-65535 -n 1 2>/dev/null) ||
                snell_port=$(awk -v min=10000 -v max=65535 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
        done
        [ -z "$snell_port" ] && error "Snell port is required with --shadow-tls, please re-run the script with --snell-port option"
    }

    [ -z "$snell_psk" ] && {
        [ -f "$snell_config_file" ] && snell_psk="$(grep 2>/dev/null <"$snell_config_file" -oE "psk = .*" | awk -F '=' '{print $NF}' | tr -d ' ')"
        [ -z "$snell_psk" ] && {
            snell_psk="$(pwgen -ns 32 1 2>/dev/null)" ||
                snell_psk="$(uuidgen -r 2>/dev/null)" ||
                snell_psk="$(tr </dev/urandom -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 2>/dev/null)"
        }
        [ -z "$snell_psk" ] && error "Snell PSK is required with --shadow-tls, please re-run the script with --snell-psk option"
    }

    [ -z "$shadow_tls_password" ] && {
        [ -f "$shadow_tls_default_file" ] && shadow_tls_password=$(grep 2>/dev/null <"$shadow_tls_default_file" -oE "shadow_tls_password=.*" | awk -F '=' '{print $NF}' | tr -d ' ')
        [ -z "$shadow_tls_password" ] && {
            shadow_tls_password="$(pwgen -ns 32 1 2>/dev/null)" ||
                shadow_tls_password="$(uuidgen -r 2>/dev/null)" ||
                shadow_tls_password="$(tr </dev/urandom -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 2>/dev/null)"
        }
        [ -z "$shadow_tls_password" ] && error "Shadow TLS password is required with --shadow-tls, please re-run the script with --shadow-tls-password option"
    }

    [ -z "$shadow_tls_port" ] && {
        [ -f "$shadow_tls_default_file" ] && shadow_tls_port=$(grep 2>/dev/null <"$shadow_tls_default_file" -oE "shadow_tls_port=.*" | awk -F '=' '{print $NF}' | tr -d ' ')
        # should not use snell port
        while [ -z "$shadow_tls_port" ] || [ "$shadow_tls_port" = "$shadowsocks_port" ] || [ "$shadow_tls_port" = "$snell_port" ] || [ "$shadow_tls_port" = "$ssh_port" ]; do
            shadow_tls_port=$(shuf -i 10000-65535 -n 1 2>/dev/null) ||
                shadow_tls_port=$(awk -v min=10000 -v max=65535 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
        done
        [ -z "$shadow_tls_port" ] && error "Shadow TLS port is required with --shadow-tls, please re-run the script with --shadow-tls-port option"
    }

    [ -z "$shadow_tls_obfs_host" ] && {
        [ -f "$snell_config_file" ] && shadow_tls_obfs_host="$(grep 2>/dev/null <"$snell_config_file" -oE "obfs-host = .*" | awk -F '=' '{print $NF}' | tr -d ' ')"
        [ -z "$shadow_tls_obfs_host" ] && [ -f "$shadow_tls_default_file" ] && {
            shadow_tls_obfs_host="$(grep 2>/dev/null <"$shadow_tls_default_file" -oE "obfs_host=.*" | awk -F '=' '{print $NF}' | tr -d ' ')"
        }
        [ -z "$shadow_tls_obfs_host" ] && {
            warn "Shadow TLS obfs host is not set, will use gateway.icloud.com as default"
            shadow_tls_obfs_host="gateway.icloud.com"
        }
    }

    [ -z "$snell_version" ] && {
        [ -f "$snell_config_file" ] && snell_version="$(grep 2>/dev/null <"$snell_config_file" -oE "version = .*" | awk -F '=' '{print $NF}' | tr -d ' ')"
        [ -z "$snell_version" ] && {
            warn "Snell version is not set, will use 4 as default"
            snell_version=4
        }
    }
}

[ -n "$authorized_keys_url" ] && {
    authorized_keys="$(curl -sL "$authorized_keys_url" 2>/dev/null)" ||
        authorized_keys="$(wget -qO- "$authorized_keys_url" 2>/dev/null)" ||
        authorized_keys="$(busybox wget -qO- "$authorized_keys_url" 2>/dev/null)"
}

[ -z "$authorized_keys" ] && authorized_keys="$(cat /home/"$username"/.ssh/authorized_keys 2>/dev/null)"

ssh_key_file="$wd/ssh_key"
ssh_private_key=""
[ -z "$authorized_keys" ] && {
    rm -f "$ssh_key_file"
    ssh-keygen -t rsa -b 4096 -C "$username@$hostname" -f "$ssh_key_file" -q -N "" >/dev/null 2>&1
    [ -f "$ssh_key_file" ] && {
        authorized_keys="$(cat "$ssh_key_file.pub" 2>/dev/null)"
        ssh_private_key="$(cat "$ssh_key_file" 2>/dev/null)"
    }
}

[ -z "$ssh_port" ] && {
    ssh_port="$(grep <"/etc/ssh/sshd_config" "Port " 2>/dev/null | cut -d' ' -f2)"
    [ -z "$ssh_port" ] && ssh_port="22"
}

[ -z "$ip_address" ] && ip_address="$(ip_address)"
[ -z "$gateway" ] && gateway="$(default_gateway)"
[ -z "$netmask" ] && netmask="$(netmask)"
[ -z "$dns" ] && dns="$(dns)"
[ -z "$ip_address" ] && error "failed to get ip address"
[ -z "$netmask" ] && error "failed to get netmask"
[ -z "$gateway" ] && error "failed to get gateway"
[ -z "$dns" ] && {
    warn "failed to get dns, will use 1.1.1.1 as default"
    dns="1.1.1.1"
}

[ "$static_ip" == true ] && {
    interface="$(default_interface)"
    [ -z "$interface" ] && error "failed to get interface with static ip"
}

[ "$network_console" = true ] && {
    nc_password="$(pwgen -nsy 16 1 2>/dev/null)" ||
        nc_password="$(openssl rand -base64 16 2>/dev/null)" ||
        nc_password="$(busybox mkpasswd -l 16 -C 8 -s 4 2>/dev/null)" ||
        nc_password="$(busybox pwgen -nsy 16 1 2>/dev/null)" ||
        nc_password="$(LC_ALL=C tr </dev/urandom -dc 'a-zA-Z0-9' | head -c 16 2>/dev/null)"
}

warn "#######################################################################"
warn "version:                 $version"
warn "mirror:                  $mirror_base"
warn "username:                $username"
warn "uid:                     $uid"
[ -n "$password" ] && warn "password:                $password"
[ -n "$password_hash" ] && warn "password hash:           $password_hash"
warn "hostname:                $hostname"
warn "domain:                  $domain"
warn "timezone:                $timezone"
warn "ntp server:              $ntp_server"
warn "network console:         $network_console"
[ -n "$nc_password" ] && warn "netwrk console password: $nc_password"
warn "install Shadowsocks:     $install_shadowsocks"
[ "$install_shadowsocks" = true ] && {
    warn "shadowsocks port:        $shadowsocks_port"
    warn "shadowsocks password:    $shadowsocks_password"
    warn "sahdowsocks obfs host:   $shadowsocks_obfs_host"
}
warn "use static ip:           $static_ip"
warn "interface:               $interface"
warn "ip:                      $ip_address"
warn "netmask:                 $netmask"
warn "gateway:                 $gateway"
warn "dns:                     $dns"
warn "ssh port:                $ssh_port"
[ -n "$ssh_private_key" ] && warn "ssh private key: \n$ssh_private_key"
[ -n "$authorized_keys" ] && warn "ssh public key: \n$authorized_keys"
warn "install Shadow TLS       $install_shadow_tls"
[ "$install_shadow_tls" = true ] && {
    warn "snell port:              $snell_port"
    warn "snell psk:               $snell_psk"
    warn "shadow-tls port:         $shadow_tls_port"
    warn "shadow-tls password:     $shadow_tls_password"
    warn "shadow-tls obfs host:    $shadow_tls_obfs_host"
}
warn "#######################################################################"

preseed_file="$wd/preseed.cfg"

cat >>"$preseed_file" <<EOF
# Localization
d-i debian-installer/language string en
d-i debian-installer/country string US
d-i debian-installer/locale string en_US.UTF-8
d-i keyboard-configuration/xkb-keymap select us
d-i lowmem/low note

# Network configuration
# netcfg will choose an interface that has link if possible. This makes it
# skip displaying a list if there is more than one interface.
d-i netcfg/choose_interface select $interface
EOF

if [ "$static_ip" = true ]; then
    # Static IP configuration.
    cat >>"$preseed_file" <<EOF
# Static IP configuration.
d-i netcfg/disable_autoconfig boolean true
EOF
else
    # DHCP configuration.
    cat >>"$preseed_file" <<EOF
# DHCP configuration.
d-i netcfg/dhcp_timeout string 60
d-i netcfg/dhcpv6_timeout string 60
d-i netcfg/dhcp_failed note
d-i netcfg/dhcp_options select Configure network manually
EOF
fi
cat >>"$preseed_file" <<EOF
d-i netcfg/get_ipaddress string $ip_address
d-i netcfg/get_netmask string $netmask
d-i netcfg/get_gateway string $gateway
d-i netcfg/get_nameservers string $dns
d-i netcfg/hostname string $hostname
d-i netcfg/domain string $domain
d-i netcfg/get_hostname string $hostname
d-i netcfg/get_domain string$domain
d-i netcfg/no_default_route boolean true
d-i netcfg/confirm_static boolean true
d-i hw-detect/load_firmware boolean true

EOF

[ "$network_console" = true ] && {
    cat >>"$preseed_file" <<EOF
# Network console

d-i anna/choose_modules string network-console
d-i preseed/early_command string anna-install network-console
EOF
    if [ -n "$authorized_keys_url" ]; then
        cat >>"$preseed_file" <<EOF
d-i network-console/authorized_keys_url string $authorized_keys_url
EOF
    else
        cat >>"$preseed_file" <<EOF
d-i network-console/password password $nc_password
d-i network-console/password-again password $nc_password
EOF
    fi
    cat >>"$preseed_file" <<EOF
d-i network-console/start select Continue
EOF
}

cat >>"$preseed_file" <<EOF

# Mirror settings
d-i mirror/country string manual
d-i mirror/protocol string $mirror_protocol
d-i mirror/$mirror_protocol/hostname string $mirror_host
d-i mirror/$mirror_protocol/directory string $mirror_directory
d-i mirror/$mirror_protocol/proxy string $mirror_proxy
d-i mirror/suite string $suite

# Account setup
d-i passwd/root-login boolean false
# To create a normal user account.
d-i passwd/user-fullname string $full_name
d-i passwd/username string $username
d-i passwd/user-password-crypted password $password_hash
# Create the first user with the specified UID instead of the default.
d-i passwd/user-uid string $uid
d-i user-setup/allow-password-weak boolean false
d-i user-setup/encrypt-home boolean false

# Clock and time zone setup
d-i time/zone string $timezone
d-i clock-setup/utc boolean true
d-i clock-setup/ntp boolean true
d-i clock-setup/ntp-server string $ntp_server

# Partitioning

EOF

echo "d-i partman-auto/method string regular" >>"$preseed_file"

[ -z "$disk" ] && disk="$(get_disk)"
if [ -z "$disk" ]; then
    # shellcheck disable=SC2016
    echo 'd-i partman/early_command string debconf-set partman-auto/disk "$(list-devices disk | head -n 1)"' >>"$preseed_file"
else
    [[ "$disk" =~ ^/dev/ ]] || disk="/dev/$disk"
    echo "d-i partman-auto/disk string $disk" >>"$preseed_file"
fi

[ "$gpt" = true ] && {
    cat >>"$preseed_file" <<EOF
d-i partman-partitioning/choose_label string gpt
d-i partman-partitioning/default_label string gpt
EOF
}

cat >>"$preseed_file" <<EOF
d-i partman/default_filesystem string $filesystem
EOF

cat >>"$preseed_file" <<'EOF'
d-i partman-auto/expert_recipe string           \
    naive ::                                    \
EOF
if [ "$efi" = true ]; then
    # shellcheck disable=SC2129
    cat >>"$preseed_file" <<EOF
    $esp $esp $esp fat32                       \\
EOF
    cat >>"$preseed_file" <<"EOF"
            $iflabel{ gpt }                     \
            $primary{ }                         \
            $reusemethod{ }                     \
            method{ efi }                       \
            format{ }                           \
            .                                   \
EOF

    cat >>"$preseed_file" <<EOF
        $boot_size $boot_size $boot_size ext4                        \\
EOF

    cat >>"$preseed_file" <<"EOF"
            $primary{ }                         \
            $bootable{ }                        \
            method{ format }                    \
            format{ }                           \
            use_filesystem{ }                   \
            filesystem{ ext4 }                  \
            mountpoint{ /boot }                 \
            .                                   \
EOF
else
    cat >>"$preseed_file" <<"EOF"
        1 1 1 free                              \
            $primary{ }                         \
            $bios_boot{ }                       \
            $reusemethod{ }                     \
EOF

    [ "$gpt" == true ] && {
        cat >>"$preseed_file" <<"EOF"
            $iflabel{ gpt }                     \
EOF
    }
    cat >>"$preseed_file" <<"EOF"
            method{ biosgrub }                  \
        .                                       \
EOF
fi

cat >>"$preseed_file" <<"EOF"
        1024 1024 -1 $default_filesystem        \
            method{ format }                    \
            format{ }                           \
            use_filesystem{ }                   \
            $default_filesystem{ }              \
            mountpoint{ / }                     \
    .
EOF
if [ "$efi" = true ]; then
    cat >>"$preseed_file" <<"EOF"
d-i partman-efi/non_efi_system boolean true
EOF
fi

cat >>"$preseed_file" <<EOF
d-i partman-auto/choose_recipe select naive
d-i partman-basicfilesystems/no_swap boolean false
d-i partman-partitioning/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
d-i partman/confirm_nooverwrite boolean true
# If one of the disks that are going to be automatically partitioned
# contains an old LVM configuration, the user will normally receive a
# warning. Preseed this away
d-i partman-lvm/device_remove_lvm boolean true

# And the same goes for the confirmation to write the lvm partitions.
d-i partman-lvm/confirm boolean true
EOF

cat >>"$preseed_file" <<EOF

# Base system installation
d-i base-installer/kernel/image string $kernel
d-i base-installer/install-recommends boolean false
EOF

[ "$security_repository" = mirror ] && security_repository=$mirror_protocol://$mirror_host${mirror_directory%/*}/debian-security

[ -z "$security_archive" ] && {
    case $suite in
    buster | oldoldstable | bullseye | oldstable)
        security_archive="$suite/updates"
        ;;
    bookworm | stable | trixie | testing)
        security_archive="$suite-security"
        ;;
    sid | unstable)
        security_archive=''
        ;;
    *)
        error "Unsupported suite: $suite"
        ;;
    esac
}

if [ "$use_backports" = true ]; then
    cat >>"$preseed_file" <<EOF
# Apt setup
d-i apt-setup/services-select multiselect updates, backports
EOF
else
    cat >>"$preseed_file" <<EOF
# Apt setup
d-i apt-setup/services-select multiselect updates
EOF
fi

# If not sid/unstable
[ -n "$security_archive" ] && {
    cat >>"$preseed_file" <<EOF
d-i apt-setup/local0/repository string $security_repository $security_archive main
d-i apt-setup/local0/source boolean true
EOF
}

cat >>"$preseed_file" <<EOF

# Package selection
tasksel tasksel/first multiselect ssh-server
d-i pkgsel/include string $packages
d-i pkgsel/upgrade select $upgrade

popularity-contest popularity-contest/participate boolean false
EOF

boot_disk="$disk"
[ -z "$boot_disk" ] && boot_disk="default"

cat >>"$preseed_file" <<EOF
# Boot loader installation

d-i grub-installer/bootdev string $boot_disk
EOF

[ "$force_efi_extra_removable" = true ] && {
    cat >>"$preseed_file" <<EOF
d-i grub-installer/force-efi-extra-removable boolean true
EOF
}

# trim leading and trailing spaces
kernal_params="$(echo "$kernal_params" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
[ -n "$kernal_params" ] && {
    cat >>"$preseed_file" <<EOF
d-i debian-installer/add-kernel-opts string $kernal_params
EOF
}

cat >>"$preseed_file" <<EOF
# Finishing up the installation
# Avoid that last message about the install being complete.
EOF

cat >>"$preseed_file" <<EOF
d-i finish-install/reboot_in_progress note
d-i debian-installer/exit/reboot boolean true
# Verbose output and no boot splash screen.
d-i debian-installer/quiet boolean false
d-i debian-installer/splash boolean false
EOF

[ "$provision" = true ] && {
    late_command="curl -sL $base/provision | bash -s --"

    if ipv6_enabled; then
        late_command="$late_command --ipv6-dhcp"
    fi

    [ -n "$username" ] && late_command="$late_command --username \"$username\""
    [ -n "$ssh_port" ] && late_command="$late_command --ssh \"$ssh_port\""
    [ -n "$authorized_keys" ] && late_command="$late_command --authorized-keys \"$authorized_keys\""
    [ "$install_socat" = true ] && late_command="$late_command --socat"
    [ "$install_go" = true ] && late_command="$late_command --go"
    [ "$install_im" = true ] && late_command="$late_command --im"
    [ "$install_neofetch" = true ] && late_command="$late_command --neofetch"
    [ "$install_fish" = true ] && late_command="$late_command --fish"
    [ "$bbr" = true ] && late_command="$late_command --bbr"
    [ "$use_backports" = true ] && late_command="$late_command --backports"
    [ "$byobu" = true ] && late_command="$late_command --byobu"
    [ "$sudo_without_password" = true ] && late_command="$late_command --sudo-without-password"

    [ "$install_shadowsocks" = true ] && {
        late_command="$late_command --shadowsocks"
        [ -n "$shadowsocks_port" ] && late_command="$late_command --shadowsocks-port \"$shadowsocks_port\""
        [ -n "$shadowsocks_password" ] && late_command="$late_command --shadowsocks-password \"$shadowsocks_password\""
        [ -n "$shadowsocks_obfs_host" ] && late_command="$late_command --shadowsocks-obfs-host \"$shadowsocks_obfs_host\""
    }

    [ "$install_shadow_tls" = true ] && {
        late_command="$late_command --shadow-tls"
        [ -n "$shadow_tls_password" ] && late_command="$late_command --shadow-tls-password \"$shadow_tls_password\""
        [ -n "$shadow_tls_port" ] && late_command="$late_command --shadow-tls-port \"$shadow_tls_port\""
        [ -n "$shadow_tls_obfs_host" ] && late_command="$late_command --shadow-tls-obfs \"$shadow_tls_obfs_host\""
        [ -n "$snell_port" ] && late_command="$late_command --snell-port \"$snell_port\""
        [ -n "$snell_psk" ] && late_command="$late_command --snell-psk \"$snell_psk\""
    }

    [ -n "$late_command" ] && {
        cat >>"$preseed_file" <<EOF
# Provisioning
d-i preseed/late_command string in-target sh -c '$late_command'
EOF
    }
}

pushd "$wd" >/dev/null 2>&1 || error "Failed to change directory to $wd"
base_url="$mirror_base/dists/$suite/main/installer-$arch/current/images/netboot/debian-installer/$arch"
[ "$daily" = true ] && {
    new_base_url="https://d-i.debian.org/daily-images/$arch/daily/netboot/debian-installer/$arch"
    if curl -s --head "$new_base_url/initrd.gz" | head -n 1 | grep -q 200; then
        base_url="$new_base_url"
    else
        warn "Daily build not found, using stable build instead"
    fi
}
firmware_url="https://cdimage.debian.org/cdimage/unofficial/non-free/firmware/$suite/current/firmware.cpio.gz"

timestamp=$(date '+%Y%m%d%H%M%S')
download "$base_url/linux" linux
download "$base_url/initrd.gz" initrd.gz
[ "$firmware" = true ] && download "$firmware_url" firmware.cpio.gz

[ ! -f "linux" ] && error "Failed to download $base_url/linux"
[ ! -f "initrd.gz" ] && error "Failed to download $base_url/initrd.gz"
[ "$firmware" = true ] && [ ! -f "firmware.cpio.gz" ] && error "Failed to download $firmware_url"

gzip -d initrd.gz 2>/dev/null || error "Failed to decompress initrd.gz"
[ ! -f initrd ] && error "Failed to decompress initrd.gz"
# cpio reads a list of file names from the standard input
echo preseed.cfg | cpio -o -H newc -A -F initrd
gzip -1 initrd

! [ -f initrd.gz ] && error "Failed to create initrd.gz"

installer_directory="$boot_dir/debian-$suite-$arch-$timestamp"
[ -d "$installer_directory" ] && rm -rf "$installer_directory"
mkdir -p "$installer_directory"
[ ! -d "$installer_directory" ] && error "Failed to create $installer_directory"

mv linux "$installer_directory"
mv initrd.gz "$installer_directory"
[ "$firmware" = true ] && {
    mv firmware.cpio.gz "$installer_directory"
}

mkrelpath=$installer_directory
[ "$dry_run" = true ] && mkrelpath=/boot
installer_directory=$(grub-mkrelpath "$mkrelpath" 2>/dev/null) ||
    installer_directory=$(grub2-mkrelpath "$mkrelpath" 2>/dev/null) || {
    error 'Could not find "grub-mkrelpath" or "grub2-mkrelpath" command'
}
[ "$dry_run" = true ] && installer_directory="$installer_directory/debian-$suite"

grub_dir=$(find /boot -type d -name "grub*" 2>/dev/null | head -n1)
grub_cfg=$(find "$grub_dir" -regextype posix-egrep -regex ".*/(grub.conf|grub.cfg)" 2>/dev/null)
[ -z "$grub_cfg" ] && grub_cfg=$(find /boot -regextype posix-egrep -regex ".*/(grub.conf|grub.cfg)" 2>/dev/null | head -n1)
[ -z "$grub_cfg" ] && error "Failed to find grub.cfg"
[ ! -f "$grub_cfg" ] && error "Failed to find grub.cfg at $grub_cfg"
[ "$dry_run" == false ] && cp "$grub_cfg" "$grub_cfg.$timestamp.bak"
title="Install Debian $suite $arch"

kernel_params="$kernel_params lowmem/low=1"
[ -n "$force_lowmem" ] && kernel_params="$kernel_params lowmem=+$force_lowmem"
initrd="$installer_directory/initrd.gz"
[ "$firmware" = true ] && initrd="$initrd $installer_directory/firmware.cpio.gz"
rm -f "$grub_custom_file" 2>/dev/null
cat >"$grub_custom_file" <<"EOF"
#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
EOF
cat >>"$grub_custom_file" <<EOF
menuentry '$title' {
    insmod part_msdos
    insmod part_gpt
    insmod ext2
    insmod xfs
    insmod btrfs
    linux $installer_directory/linux$kernel_params
    initrd $initrd
}
EOF
[[ ! -f "$grub_custom_file" ]] && error "grub menu not generated"

chmod +x "$grub_custom_file"
# create a temp file to hold the grub.cfg if we are doing a dry run
[ "$dry_run" = true ] && grub_cfg=$wd/grub.cfg
grub-mkconfig -o "$grub_cfg" 2>/dev/null || grub2-mkconfig -o "$grub_cfg" 2>/dev/null || {
    error 'Could not find "grub-mkconfig" or "grub2-mkconfig" command'
}
[ ! -f "$grub_cfg" ] && error "grub menu not generated"
! grep -q "$title" "$grub_cfg" && error "grub menu not updated"
echo "$grub_cfg updated"
popd >/dev/null 2>&1 || error "Failed to change directory from $wd"

[ "$dry_run" = true ] && {
    echo "Dry run complete"
    info "#######################################################################"
    info "preseed file: $preseed_file"
    info "grub menu   : $grub_cfg"
    info "#######################################################################"
    exit 0
}

grub-reboot "$title" 2>/dev/null || grub2-reboot "$title" 2>/dev/null || {
    error 'Could not find "grub-reboot" or "grub2-reboot" command'
}
echo "rebooting..."
sleep 3
reboot